"""
Test suite for PV Predictor.

Tests PV production forecasting with weather integration.
"""

from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
import pytest

from pems_v2.models.predictors.pv_predictor import PVPredictor


@pytest.fixture
def pv_config():
    """Sample PV predictor configuration."""
    return {
        "pv_system": {
            "capacity_kw": 10.0,
            "panel_tilt": 30.0,
            "panel_azimuth": 180.0,
            "latitude": 49.2,
            "longitude": 16.6,
        },
        "model_dir": "test_models",
        "random_state": 42,
        "validation_split": 0.2,
        "ml_weight": 0.7,
        "physics_weight": 0.3,
        "quantiles": [0.1, 0.5, 0.9],
        "lookback_hours": 24,
        "forecast_horizon": 48,
    }


@pytest.fixture
def sample_weather_data():
    """Create sample weather data."""
    dates = pd.date_range("2024-01-01 00:00:00", "2024-01-02 23:45:00", freq="15min")

    weather_df = pd.DataFrame(
        {
            "temperature_2m": np.random.normal(10, 5, len(dates)),
            "cloudcover": np.random.uniform(0, 100, len(dates)),
            "shortwave_radiation": np.random.uniform(0, 800, len(dates)),
            "direct_radiation": np.random.uniform(0, 600, len(dates)),
            "diffuse_radiation": np.random.uniform(0, 200, len(dates)),
            "precipitation": np.random.uniform(0, 10, len(dates)),
            "windspeed_10m": np.random.uniform(0, 20, len(dates)),
            "relativehumidity_2m": np.random.uniform(30, 90, len(dates)),
        },
        index=dates,
    )

    return weather_df


@pytest.fixture
def sample_pv_data():
    """Create sample PV production data."""
    dates = pd.date_range("2024-01-01 00:00:00", "2024-01-02 23:45:00", freq="15min")

    # Create realistic PV pattern (day/night cycle)
    hour = dates.hour
    pv_power = np.where(
        (hour >= 6) & (hour <= 18),
        np.random.uniform(0, 10000, len(dates)) * np.sin(np.pi * (hour - 6) / 12),
        0,
    )

    pv_df = pd.DataFrame(
        {
            "InputPower": pv_power,
            "PV1InputPower": pv_power * 0.5,
            "PV2InputPower": pv_power * 0.5,
            "PV1Voltage": np.random.uniform(40, 60, len(dates)),
            "PV2Voltage": np.random.uniform(40, 60, len(dates)),
        },
        index=dates,
    )

    return pv_df


class TestPVPredictor:
    """Test suite for PV Predictor."""

    def test_initialization(self, pv_config):
        """Test PV predictor initialization."""
        predictor = PVPredictor(pv_config)

        assert predictor.capacity_kw == 10.0
        assert predictor.panel_tilt == 30.0
        assert predictor.panel_azimuth == 180.0
        assert predictor.location_lat == 49.2
        assert predictor.location_lon == 16.6
        assert predictor.ml_weight == 0.7
        assert predictor.physics_weight == 0.3

        # Check feature lists
        assert "temperature_2m" in predictor.weather_features
        assert "cloudcover" in predictor.weather_features
        assert "hour" in predictor.temporal_features
        assert "day_of_year" in predictor.temporal_features

    def test_weather_feature_creation(self, pv_config, sample_weather_data):
        """Test weather feature engineering."""
        predictor = PVPredictor(pv_config)

        # Mock pvlib solar position calculation
        with patch.object(predictor.location, "get_solarposition") as mock_solar_pos, patch.object(
            predictor.location, "get_clearsky"
        ) as mock_clear_sky:
            # Mock solar position data
            mock_solar_pos.return_value = pd.DataFrame(
                {
                    "elevation": np.random.uniform(0, 80, len(sample_weather_data)),
                    "azimuth": np.random.uniform(0, 360, len(sample_weather_data)),
                    "apparent_zenith": np.random.uniform(0, 90, len(sample_weather_data)),
                },
                index=sample_weather_data.index,
            )

            # Mock clear sky data
            mock_clear_sky.return_value = pd.DataFrame(
                {
                    "ghi": np.random.uniform(0, 1000, len(sample_weather_data)),
                    "dni": np.random.uniform(0, 800, len(sample_weather_data)),
                    "dhi": np.random.uniform(0, 300, len(sample_weather_data)),
                },
                index=sample_weather_data.index,
            )

            weather_features = predictor.create_weather_features(sample_weather_data)

            # Check that new features were created
            assert "sun_elevation" in weather_features.columns
            assert "sun_azimuth" in weather_features.columns
            assert "clear_sky_ghi" in weather_features.columns
            assert "temp_efficiency" in weather_features.columns
            assert len(weather_features) == len(sample_weather_data)

    def test_temporal_feature_creation(self, pv_config, sample_weather_data):
        """Test temporal feature engineering."""
        predictor = PVPredictor(pv_config)

        temporal_features = predictor.create_temporal_features(sample_weather_data.index)

        # Check temporal features
        assert "hour" in temporal_features.columns
        assert "day_of_year" in temporal_features.columns
        assert "month" in temporal_features.columns
        assert "weekday" in temporal_features.columns
        assert "is_weekend" in temporal_features.columns
        assert "season" in temporal_features.columns

        # Check cyclical encoding
        assert "hour_sin" in temporal_features.columns
        assert "hour_cos" in temporal_features.columns
        assert "day_sin" in temporal_features.columns
        assert "day_cos" in temporal_features.columns

        # Check value ranges
        assert temporal_features["hour"].min() >= 0
        assert temporal_features["hour"].max() <= 23
        assert temporal_features["season"].min() >= 0
        assert temporal_features["season"].max() <= 3

        # Check cyclical encoding bounds
        assert temporal_features["hour_sin"].min() >= -1
        assert temporal_features["hour_sin"].max() <= 1
        assert temporal_features["hour_cos"].min() >= -1
        assert temporal_features["hour_cos"].max() <= 1

    @patch("pvlib.irradiance.get_total_irradiance")
    @patch("pvlib.temperature.faiman")
    def test_physical_model_calculation(
        self, mock_temp, mock_irradiance, pv_config, sample_weather_data
    ):
        """Test PVLib physical model calculation."""
        predictor = PVPredictor(pv_config)

        # Mock pvlib functions
        mock_irradiance.return_value = {
            "poa_global": pd.Series(
                np.random.uniform(0, 1000, len(sample_weather_data)),
                index=sample_weather_data.index,
            )
        }
        mock_temp.return_value = pd.Series(
            np.random.uniform(20, 50, len(sample_weather_data)),
            index=sample_weather_data.index,
        )

        with patch.object(predictor.location, "get_solarposition") as mock_solar_pos:
            mock_solar_pos.return_value = pd.DataFrame(
                {
                    "apparent_zenith": np.random.uniform(0, 90, len(sample_weather_data)),
                    "azimuth": np.random.uniform(0, 360, len(sample_weather_data)),
                },
                index=sample_weather_data.index,
            )

            physical_prediction = predictor.calculate_physical_model_baseline(sample_weather_data)

            # Check output
            assert isinstance(physical_prediction, pd.Series)
            assert len(physical_prediction) == len(sample_weather_data)
            assert physical_prediction.min() >= 0  # No negative power
            assert physical_prediction.max() <= predictor.capacity_kw  # Within capacity

    def test_training_data_preparation(self, pv_config, sample_pv_data, sample_weather_data):
        """Test training data preparation."""
        predictor = PVPredictor(pv_config)

        # Mock physical model calculation
        with patch.object(predictor, "calculate_physical_model_baseline") as mock_physical:
            mock_physical.return_value = pd.Series(
                np.random.uniform(0, 10, len(sample_pv_data)),
                index=sample_pv_data.index,
            )

            # Mock solar position and clear sky
            with patch.object(
                predictor.location, "get_solarposition"
            ) as mock_solar_pos, patch.object(predictor.location, "get_clearsky") as mock_clear_sky:
                mock_solar_pos.return_value = pd.DataFrame(
                    {
                        "elevation": np.random.uniform(0, 80, len(sample_pv_data)),
                        "azimuth": np.random.uniform(0, 360, len(sample_pv_data)),
                        "apparent_zenith": np.random.uniform(0, 90, len(sample_pv_data)),
                    },
                    index=sample_pv_data.index,
                )

                mock_clear_sky.return_value = pd.DataFrame(
                    {
                        "ghi": np.random.uniform(0, 1000, len(sample_pv_data)),
                        "dni": np.random.uniform(0, 800, len(sample_pv_data)),
                        "dhi": np.random.uniform(0, 300, len(sample_pv_data)),
                    },
                    index=sample_pv_data.index,
                )

                X, y = predictor.prepare_training_data(sample_pv_data, sample_weather_data)

                # Check output shapes and content
                assert isinstance(X, pd.DataFrame)
                assert isinstance(y, pd.Series)
                assert len(X) == len(y)
                assert len(X) > 0  # Should have valid data after dropping NaNs

                # Check that features were created
                assert "physical_baseline" in X.columns
                assert any("hour" in col for col in X.columns)
                assert any("temperature" in col for col in X.columns)

                # Check target variable conversion (should be in kW)
                assert y.max() <= 15.0  # Reasonable upper bound for 10kW system in kW

    def test_prediction_without_training(self, pv_config, sample_weather_data):
        """Test that prediction fails when model is not trained."""
        predictor = PVPredictor(pv_config)

        with pytest.raises(ValueError, match="Model not trained yet"):
            predictor.predict(sample_weather_data)

    def test_feature_importance_extraction(self, pv_config):
        """Test feature importance extraction."""
        predictor = PVPredictor(pv_config)

        # Mock trained model with feature importances
        predictor.ml_model = MagicMock()
        predictor.feature_columns = ["feature1", "feature2", "feature3"]
        predictor.ml_model.feature_importances_ = np.array([0.5, 0.3, 0.2])

        importance = predictor.get_feature_importance()

        assert isinstance(importance, dict)
        assert len(importance) == 3
        assert importance["feature1"] == 0.5
        assert importance["feature2"] == 0.3
        assert importance["feature3"] == 0.2

        # Should be sorted by importance
        importance_values = list(importance.values())
        assert importance_values == sorted(importance_values, reverse=True)

    def test_online_learning_disabled(self, pv_config, sample_weather_data):
        """Test online learning when disabled."""
        pv_config["enable_online_learning"] = False
        predictor = PVPredictor(pv_config)

        X_new = sample_weather_data[:10]
        y_new = pd.Series(np.random.uniform(0, 10, 10), index=X_new.index)

        success = predictor.update_online(X_new, y_new)
        assert not success  # Should fail when disabled

    def test_online_learning_no_model(self, pv_config, sample_weather_data):
        """Test online learning when no model is trained."""
        pv_config["enable_online_learning"] = True
        predictor = PVPredictor(pv_config)

        X_new = sample_weather_data[:10]
        y_new = pd.Series(np.random.uniform(0, 10, 10), index=X_new.index)

        success = predictor.update_online(X_new, y_new)
        assert not success  # Should fail when no model

    def test_prediction_clipping(self, pv_config):
        """Test that predictions are clipped to physical limits."""
        predictor = PVPredictor(pv_config)

        # Mock a trained model that might predict beyond capacity
        predictor.ml_model = MagicMock()
        predictor.feature_columns = ["test_feature"]
        predictor.scaler = None

        # Mock prediction that exceeds capacity
        predictor.ml_model.predict.return_value = np.array([15.0])  # 15 kW > 10 kW capacity

        # Create simple test data
        X_test = pd.DataFrame({"test_feature": [1.0]}, index=[pd.Timestamp("2024-01-01 12:00:00")])

        # Mock metadata for version info
        predictor.metadata = MagicMock()
        predictor.metadata.version = "test_v1.0"

        result = predictor.predict(X_test)

        # Check that prediction was clipped to capacity (converted back to watts)
        assert result.predictions.iloc[0] <= predictor.capacity_kw * 1000  # Should be <= 10,000 W


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
